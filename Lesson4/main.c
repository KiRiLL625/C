#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

/*
 Как возвращать из функции 2 значения? Для этого можно пойти на небольшую хитрость:
 первое возвращаемое зачения будет возвращаться стандартно через return. А для второго
 можно использовать указатель. Рассмотрим пример:

 Допустим, у нас есть функция суммы двух чисел, но в ней нам также нужно отследить
 переполнение: если a > 1000 или a < -1000, то нам нужно это куда-то сохранить. Но ещё
 нам нужно вернуть собственно саму сумму чисел. Сумму вернём с помощью return, а вот для
 отслеживания переполнения в аргументы функции передадим какой-то указатель, например,
 error_code. И в зависимости от значения a будем что-то записывать в этот указатель:
 */

int sum(int a, int b, int *error_code){
    if(a > 1000){
        *error_code = 1;
    }
    if(a < -1000){
        *error_code = -1;
    }
    return a + b;
}

/*
 return в void-функции. Функция, обозначенная как void, ничего не возвращает, однако return
 там может быть. В данном случае он используется как break для цикла, то есть, если мы где-то
 напишем return, то программа выйдет из функции и перестанет её выполнять. Пример с переполнением:
 */

void sum2(int a, int b){
    if(a > 1000){
        return;
    }
    printf("%i\n", a + b);
}

int main() {
    //Создаём переменную для отслеживания ошибки
    int error = 0;
    //Записываем сумму в переменную res, а переменную error передаём в виде адреса
    int res = sum(10, 5, &error);
    printf("%i %i\n", res, error); //Вывод: 15 0
    //error = 0, а значит переполнения не произошло
    res = sum(1001, 10, &error);
    printf("%i %i\n", res, error); //Вывод: 1011 1
    //error = 1, значит произошла ошибка: переменная а больше 1000

    //Вот таким хитрым образом можно возвращать несколько значений из функции


    //Примеры с функцией sum2:
    sum2(10, 5); //Вывод: 15
    sum2(1001, 5); //Ничего не выведет, так как return прекращает работу функции

    /*
     Подробнее про символы. Символы хранятся в переменных с типом данных char и указываются
     в одинарных кавычках (разница между двойными и одинарными кавычками большая!). Но вообще
     тип char - тип данных, содержащий целые числа, а значит мы можем задавать символы с помощью
     цифр. Как же так получается? Каждый символ хранится в виде кода ASCII, где каждому символу
     соответствует определённое числовое значение, например:
     */

    char a = 'c';
    printf("%c %i\n", a, a); //Вывод: с 99

    /*
     С помощью %c мы вывели сам символ, а с помощью %i мы вывели ASCII-код этого символа.
     Таким же образом можно задавать и непечатные символы (те, которые мы не видим), например,
     пробел или перенос на следующую строку, а также звуковые сигналы. Пример:
     */

    char sound = 7;
    printf("%c\n", sound); //Вывелся стандартный системный звук (на разных
    //операционных системах разный звук)

    /*
     Символы можно вводить и выводть в консоль с помощью функций getchar() и
     putchar():
     */
    char b = getchar();
    putchar(b);

    /*
     Нужно обратить внимание, что функция getchar() возвращает int, поэтому иногда
     нужно явно преобразовывать полученное значение к типу char, но чаще всего этого
     делать не нужно:
     */
    b = (char) getchar(); //правильнее
    b = getchar(); //но так тоже допустимо

    /*
     Строки. Строки - массив символов, можно их записывать с помощью массива или
     указателя:
     */
    //5 вариантов записи строк:
    char str1[] = "Hello, World!";
    char str2[20] = "Hello, World!";
    char* str3 = "Hello, World!";
    char str4[] = {'a', 'b', 'c', '\0'};
    char str5[10] = {'a', 'b', 'c', '\0'};

    /*
     Разница одинарных кавычек и двойных на простом примере:
     'c' = c
     "c" = {'c', '\0'}

     \0 - нуль-терминатор - символ окончания строки
     */

    /*
     Функции ввода и вывода строк. Есть несколько функций для ввода и вывода строк:
     gets(), puts(), fgets(), fputs(), а также getline() - особая функция, которую мы чуть позже
     рассмотрим.

     Сперва рассмотрим функции gets() и puts():
     */

    char str[20];
    gets(str); //Вводим строку
    puts(str); //Выводим строку

    /*
     Казалось бы, всё работает нормально, но нет. Проблема функции gets() в том, что она
     не проверяет заданную изначально длину строки, и если мы введём строку больше, чем
     задано изначально, то эта функция начнёт залезать на другие ячейки памяти, что очень
     небезопасно. Даже при использовании этой функции компилятор выдаёт предупреждение, что
     функция является небезопасной, и её лучше не использовать. Поэтому будем использовать
     функции fgets() и fputs():
     */

    fgets(str, 20, stdin);
    fputs(str, stdout);

    /*
     Вообще эти функции рассчитаны на работу с файлами, поэтому вместо названий
     файлов мы пишем stdin/stdout - стандартные потоки ввода/вывода. Также существует
     stderr - стандартный поток ошибок
     */

    /*
     Функции из заголовочного файла ctype.h. Эти функции проверяют, является ли символ
     числом или ещё чем-то. Возвращают 1 или 0. Примеры:

     isalpha() - проверяет, является ли символ буквой
     isdigit() - проверяет, является ли символ цифрой
     islower() - проверяет, находится ли символ в нижнем регистре
     и т.д.

     Есть 2 функции действия:
     tolower() и toupper() - понижают или повышают регистр
     */

    /*
     Функции заголовочного файла string.h. Там есть разный набор для работы со строками:

     strlen(s1) - возвращает длину строки s1
     strcpy(s1, s2) - копирует s2 в s1
     strcat(s1, s2) - соединяет s1 и s2 и записывает всё в s1
     strcmp(s1, s2) - возвращает 0, если s1 = s2
                                1, если s1 > s2
                                -1, если s1 < s2.
    Сравнение происходит по ASCII-кодам символов строки
    strchr(s1, char) - возвращает указатель на первое вхождение символа char в строку s1.
                        Если символ не найден - возвращает NULL.
    strstr(s1, str) - возвращает указатель на первое вхождение строки str в строку s1.
                        Если строка не найдена - возвращает NULL.
     */

    //NULL (null-pointer, nullptr) - нулевой указатель или указатель ни на что.
    //В буквальном смысле ни на что не указывает. Обычно он появляется, если произошла какая-то
    //ошибка, например, в функции или при чтении файла:

    int* n = NULL;

    /*
     Функции для перевода строки в число из stdlib.h:
     atoi(s) - переводит строку s в число int
     atof(s) - переводит строку s в число float или double
     atol(s) - переводит строку s в число long (long int)
     atoll(s) - переводит строку s в число long long (long long int)

     Также у atol() есть аналог в string.h - strtol(). Их отличие лишь в том, что
     strtol() умеет обрабатывать ошибки, однако её использование более сложное. Я, например,
     предпочитаю использовать atol().
     */
    return 0;
}
