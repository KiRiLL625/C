#include <stdio.h>
//Объявляем константу PI равную 3.14
#define PI 3.14

//Аргумент со значением
void a1(int a){
    a++;
    printf("%i\n", a);
}

//Аргумент с указателем
void a2(int* a){
    *a++;
    printf("%i\n", *a);
}

void print1(int mass[], size_t size){
    for (int i = 0; i < size; ++i) {
        printf("%i ", mass[i]);
    }
}

void print2(int *mass, size_t size){
    for (int i = 0; i < size; ++i) {
        printf("%i ", mass[i]);
    }
}

void print3(const int *mass, size_t size){
    for (int i = 0; i < size; ++i) {
        printf("%i ", mass[i]);
    }
}

int main() {
    /*
     Подробнее о форматированном выводе. Помимо того, что м можем выводить разные
     типы данных с помощью разных спецификаторов, мы ещё можем указывать точность
     дробных чисел, ширину вывода, вывод знака числа, форматировать по левому или
     правому краю. Все эти форматы задаются в следующем порядке:

     %[форматирование по левому краю][вывод знака числа][ширина].[точность][спецификатор]
     Примеры:
     */
    double a = 5.12345;
    printf("%.2f", a); //Вывод: 5.12
    printf("%.*f", 2, a); //Вывод: 5.12
    /*
     Звёздочкой мы указываем на то, что точность задаётся в виде переменной. Переменную,
     которая отвечает за точность, вводим сразу строки форматов, а только потом пишем
     переменную, которую хотим вывести.
     */
    printf("%10f", a); //Вывод:   5.12345
    /*
     Здесь мы задаём ширину вывода. Если длина символов в переменной меньше, чем ширина,
     которую мы указали, то остальное заполнится пробелами, а переменна по умолчанию
     будет отформатирована по правому краю.
     */
    printf("%*f", 10, a); //То же самое, только ширина в виде переменной

    //Можно совмещать:
    printf("%10.2f", a); //Ширина будет 10 символов, а точность - 2 знака после запятой
    printf("%*.*f", 10, 2, a); //То же, только ширина и точность задаются переменными

    //Знак числа:
    printf("%+f", a); //Вывод: +5.12345 (выводит знак, даже если число положительно
    //В целом, довольно бесполезная вещь

    //Форматирование по левому краю:

    printf("%-15f", a); //Вывод: 5.12345 (в данном случае пробелы добавляются не слева
    //от числа, а справа

    //А теперь всё вместе:
    printf("%-+*.*f", 10, 2, a); //Вывод: +5.12

    /*
     Теперь про передачу аргументов в функцию по указателю. Над функцией main() есть две функции:
     a1() и a2().

     В функции a1() аргумент передаётся по значению, то есть переменная будет скопирована
     в новую, пройдёт внутри функции какие-то действия и уничтожится.

     Если мы передаём в функцию переменную по указателю (функция a2()), то функция будет
     напрямую работать с переменной, которую мы в неё передали, так как она обращается к
     конкретной ячейке памяти. Пример:
     */

    int d = 10;
    a1(d);
    printf("%i\n", d);
    //Вывод сверху: 11 10 (то есть внутри функции значение поменялось, а сама
    //переменная не изменилась

    a2(&d);
    printf("%i\n", d);
    //Вывод: 11 11 (значение поменялось, так как мы его передали по указателю)

    /*
     Массивы и строки передаются всегда только по указателю (функции print1 и print2).
     Причём в аргументах функции мы можем писать как int mass[], так и int* mass - это
     одно и то же.
     */

    /*
     Но возникает иногда такая ситуация, что исходный массив нам менять не нужно, и его
     надо защитить от изменений. А он передаётся всегда по ссылке и может быть изменён.
     Нам на помощь приходит ключевое слово const. Он делает любую переменную константой,
     а если константой объявлен указатель, то переменная, на которую указывает этот указатель,
     будет защищена от изменений.
     */

    const int q = 10;
    q++; //Ошибка! q - константа

    /*
     В функции print3() как раз-таки применён константный указатель, так как мы массив не
     меняем, а просто его выводим на экран.

     Также константы можно объявлять с помощью директивы #define. Объявим константу вверху
     файла и попробуем её использовать:
     */
    printf("%f\n", PI);
    PI = 3.15; //Ошибка! PI - константа
    /*
     При объявлении константы таким образом тип указывать не нужно: компилятор его
     определит автоматически.
     */

    /*
     Отличие постфиксного от префиксного инкремента/декремента. Я уже говорил, что
     постфиксный инкремент (i++) сначала вернёт текущее значение, а потом только увеличит
     его на единицу. Префиксный (++i) сначал увеличит значение, а потом вернёт его. Где
     же это заметно? Вот пример:
     */
    int n1 = 10;
    int x1 = n1++;
    printf("%i %i\n", x1, n1); //Вывод: 10 11

    int n2 = 10;
    int x2 = ++n2;
    printf("%i %i\n", x2, n2); //Вывод: 11 11

    return 0;
}
