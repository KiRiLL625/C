#include <stdio.h>
#include <stdlib.h>

int main() {
    /*Работа с файлами. Чтобы работать с файлами, мы должны объявить указатель
     с типом FILE, а затем присвоить ему значение с помощью функции fopen(). Важно
     помнить, что указатель на файл выделяется на куче (как динамический массив), поэтому
     после работы с файлом его нужно закрыть функцией fclose(), а иначе произойдёт
     утечка памяти.

     Синтаксис функции fopen: fopen("filename", "mode"). Mode - параметр открытия.
     Их несколько:

     r - только для чтения
     w - для записи, при этом если файла не существует, то он создастся, а если файл
     был, то он перезапишется полностью
     a - для записи, новая информация добавится в конец файла после существующей

     r+ - для чтения и записи (обновление информации)
     w+ - для чтения и записи, при этом точно также если файла нет, то он создастся, а
     новая информация добавиться вместо старой
     a+ - для чтения и записи, новая информация добавится после конца существующей
     информации.

     rb, wb, ab, rb+, r+b, wb+, w+b, a+, a+b - для двоичных файлов (.dll, .bin и т.д.)
     (надеюсь, с этим никогда не придётся столкнуться)

     Примеры работы с файлами:
     */

    FILE *file1 = fopen("output.txt", "w+");
    if(file1 == NULL){
        //Если fopen() не может открыть/создать файл, то в указателе
        //file1 оказывается NULL
        printf("Error opening/creating file!");
    }
    fputs("Всем привет!", file1);
    //После строки сверху создастся файл output.txt, в котором окажется строка "Всем привет!"
    char str[100];
    fgets(str, 100, file1);
    //Теперь в переменной str окажется строка "Всем привет", которую мы получили из файла
    fclose(file1);

    /*
     Также есть функции fprintf() и fscanf(). Их работа аналогична обычным printf() и
     scanf(), только считывают или записывают они в файл/из файла.
     */

    /*
     И небольшое повторение работы с динамической памятью:
     */

    int *a = (int*) malloc(10*sizeof(int)); //Выделили память для 10 целых чисел в массиве
    int *b = (int*) calloc(10, sizeof(int));
    //То же, что и сверху, только все элементы теперь 0. Но иногда calloc работает плохо,
    //например, с дробными числами, и он не все числа зануляет. Поэтому для double/float
    //и некоторых других типов лучше выделить память с помощью malloc, а затем вручную занулить
    int *c = (int*) realloc(b, 10*sizeof(int)); //увеличили массив b на
    //10 элементов и записали это всё в указатель c

    /*
     Все эти функции при неудачной попытке выделения памяти кладут в указатель NULL.
     Если память увеличить не удалось, то realloc тоже вернёт NULL, а тот указатель, который
     нужно было увеличить, оставить неизменным
     */

    free(a);
    free(b);
    free(c);
    //Очистили память

    /*
     Ещё один момент: realloc(NULL, 10*sizeof(int)) = malloc(10*sizeof(int));
     realloc(a, 0) = free(a);
     */
    return 0;
}
