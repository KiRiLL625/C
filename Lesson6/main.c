#include <stdio.h>
/*
 Сортировки. Сортировка нужна тогда, когда нам нужно отсортировать какой-то массив
 данных по возрастанию или убыванию (если в массиве встречаются одинаковые элементы, то
 говорят по невозрастанию или неубыванию). Сортировки бывают разных видов, они отличаются
 тем, как элементы сортируются, и скоростью выполнения сортировки. Пока что изучим 3 основных
 вида сортировки:
 */

/*
 Сортировка вставками - сортировка, при которой мы выбираем какой-то опорный элемент
 (чаще всего это второй элемент из массива), а затем сравниваем этот элемент с элементами,
 которые стоят до него. Если элемент меньше, чем предыдущий (рассматривает сортировку по
 возрастанию), то двигаем его назад, а все остальные элементы двигаем на один вперёд. После
 этого выбираем следующий по порядку элемент, также сравниваем его с предыдущими, при
 необходимости двигаем назад, а остальные элементы перемещаем вперёд. При сортировке по убыванию
 делаем всё то же самое, только условие разворачиваем в противоположную сторону. Пример такой
 сортировки:
 */
void insertion_sort(int *arr, int n) {
    //Объявляем нужные переменные
    int i, j, key;
    for (i = 1; i < n; i++) {
        //Выбираем опорный элемент
        key = arr[i];
        j = i - 1;
        //Пока выбранный элемент не в начале массива и он меньше, чем предыдущий элемент
        while (j >= 0 && arr[j] > key) {
            //то двигаем элементы на 1 вперёд
            arr[j + 1] = arr[j];
            j--;
        }
        //Выбираем следующий элемент, как опорный
        arr[j + 1] = key;
    }
}

/*Сортровка выбором. Очень похожа на сортировку вставками, кто-то даже считает эту сортировку
разновидностью сортировки вставками. Действительно, её принцип действия очень похож. Для начала
мы пробегаемся по всему массиву и находим минимальный элемент. Затем перемещаем этот элемент
в начало массива. После этого отсекаем этот элемент от массива, снова ищем минимум, ставим его
 уже на второе место, затем отсекаем уже 2 элемента от массива, снова ищем минимум и т.д. Можно
 искать минимальный элемент и вставлять его в начало массива, можно искать максимальный элемент
 и вставлять его в конец массива - без разницы. Вариант для ускорения работы данной сортировки -
 можно искать одновременно максимум и минимум и вставлять их в разные концы массива, а затем
 отсекать массив с обеих сторон. Пример сортировки выбором:
*/
void selection_sort(int *arr, int n) {
    //Объявляем переменные
    int i, j, min, temp;
    for (i = 0; i < n - 1; i++) {
        min = i;
        //находим минимум
        for (j = i; j < n; j++) {
            if (arr[j] < arr[min])
                min = j;
        }
        //а тут просто переставляем 2 элемента с помощью временной переменной temp
        temp = arr[i];
        arr[i] = arr[min];
        arr[min] = temp;
    }
}

//2 сортировки сверху очень хорошо подходят, когда нужно отсортировать частично
//отсортированный массив

/*
 Самая простая сортировка - сортировка пузырьком - названа так, потому что элемент в ней
 как будто пробиваются наверх через другие пузырьки, сравниваясь с ними. Здесь всё просто:
 пробегаемся по массиву с помощью вложенного цикла, а внутри сравниваем двух соседей и меняем
 их местами при необходимости:
 */

void bubble_sort(int *arr, int n) {
    int i, j, temp;
    for (i = 0; i < n - 1; i++) {
        for(j = 0; j < n - i - 1; j++) {
            //условие сравнения
            if (arr[j] > arr[j + 1]) {
                //меняем 2 переменные местами
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

/*
 На практике используются более быстрые алгоритмы сортировки, такие как быстрая сортировка
 или сортировка слиянием, о которых мы поговорим на следующем занятии. Но иногда бывают
 случаи, когда вот такие простые сортировки работают быстрее сложных алгоритмов. В стандартных
 функциях сортировки других языков программирования чаще всего используется алгоритм
 быстрой сортировки
 */

int main(int argc, char *argv[]) {
    //Тут просто примеры того, что все эти сортировки работают
    int arr[] = {5, 2, 4, 6, 1, 3};
    int n = sizeof(arr) / sizeof(arr[0]);
    insertion_sort(arr, n);
    for (int i = 0; i < n; ++i) {
        printf("%i ", arr[i]);
    }
    printf("\n");
    int arr1[] = {5, 2, 4, 6, 1, 3};
    selection_sort(arr1, n);
    for (int i = 0; i < n; ++i) {
        printf("%i ", arr1[i]);
    }
    printf("\n");
    int arr2[] = {5, 2, 4, 6, 1, 3};
    bubble_sort(arr2, n);
    for (int i = 0; i < n; ++i) {
        printf("%i ", arr2[i]);
    }

    printf("\n");
    /*
     Теперь тема, которая пригодится в будущем: заголовочные файлы и сигнатуры
     функций. Если мы заглянем в код стандартной библиотеки (stdio.h) или любой другой
     библиотеки, то мы увидим, что там нет реализаций функций, там описаны просто их
     сигнатуры (функции без тела). Зачем это нужно? Раньше, когда компьютеры были слабыми
     и не могли скомпилировать всю библиотеку целиком за раз, нужно было найти какое-то решение
     для поэтапной компиляции. И разработчики Си придумали идею: в заголовочных файлах (файлы
     .h) описывались только определения функций, а в файлах .c (или файлах библиотек .a, .so
     и т.д.) записывались реализации функций. Затем, после подключения заголовочного файла
     к программе, у нас компилируется только та функция, которая была вызвана. Благодаря этой
     фиче библиотеки в Си и компиляция работают довольно быстро. Но у такого решения есть тоже
     свои недостатки.

     Теперь попробуем создать свою мини-библиотеку, в которой будет всего одна функция суммы.
     Для этого создадим файлы foo.h и foo.c. Далее комментарии написаны в этих файлах
     */
    //Подключаем наш заголовочный файл к проекту и можем пользоваться функцией sum().
    //Да-да, заголовочные файлы можно подключать не только в начале программы, но и где-то
    //в середине
#include "foo.h"
    printf("%i\n", sum(5, 3)); //Вывод: 8

    /*
     Аргументы командной строки. Что это? Это, так скажем, параметры, которые иногда
     можно задавать для выполнения программы. В средах разработки они задаются с помощью
     настроек проекта, при обычной компиляции указываются после названия программы:
     ./main input.txt (input.txt в данном случае - параметр). Чаще всего в аргументах командной
     строки лежат какие-то названия файлов, числа и т.д. Как же ими пользоваться? Для этого
     в аргументах функции main() нужно указать 2 параметра: int argc, char *argv[] (char **argv)
     где argc - количество аргументов, а argv - массив строк, в котором содержатся сами
     аргументы. argc всегда как минимум 1, а argv[0] - название программы.
     Примеры использования:
     */
    if(argc < 2){
        //Проверка, что количество аргументов больше 1.
        printf("Not enough arguments!");
    }
    else{
        //Открываем файл, имя которого задано аргументом командной строки
        FILE *file = fopen(argv[1], "r");
        fclose(file);
    }

    /*
     Указатель на void (void*). Указатель на void - указатель, который может быть сведён
     к любому типу. Такие указатели нельзя разыменовать, но их можно использовать как
     возвращаемое функцией значение, чтобы потом его использовать в других указателях.
     Указатели на void используют функции malloc, calloc, realloc, так как мы можем их
     свести к любому типу указателя.
     */
    return 0;
}
